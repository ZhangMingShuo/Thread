//Nien Notebook 2 Chapter 1
public class Main {
    public static void main(String[] args) {
        System.out.println("当前线程名称" + Thread.currentThread().getName());
        System.out.println("当前线程ID" + Thread.currentThread().getId());
        System.out.println("当前线程状态" + Thread.currentThread().getState());
        System.out.println("当前线程优先级" + Thread.currentThread().getPriority());

    }
}

        /*
1.2.2 线程的基本原理
当前线程名称main
当前线程ID1
当前线程状态RUNNABLE
当前线程优先级5
线程ID为ID1，名称为main，状态为RUNNABLE,线程优先级为5,
    在 JAVA 中，执行程序流程的重要单位是——方法；而栈内存的分配的单位是——栈帧（或
者叫方法帧）。方法的每一次执行，需要为其分配一个栈帧（方法帧），栈帧主要保存该方法中
的局部变量、方法的返回地址、以及其他的方法相关信息。当线程的执行流程进入方法时，  JVM
就会为方法分配一个对应的栈帧压入栈内存；当线程的执行流程跳出方法时，JVM 就从栈内存弹
出该方法的栈帧，此时，方法帧的局部变量的内存空间就被回收掉。
    正是由于栈帧（方法帧）的操作是后进先出的模式，这也是标准的栈的操作模式，所以存放方法帧的内存也被叫做栈内存。
    压栈次序：main方法 的栈帧，anotherFun 栈帧，anotherFun2 栈帧
    弹栈次序：main方法 的栈帧，anotherFun 栈帧，anotherFun2 栈帧
1.2.3 进程与线程的区别
    总结一下进程与线程的区别，主要为以下几点：
（1）线程是“进程代码段”的一次的顺序执行流程。一个进程由一个或多个线程组成；一个
进程至少有一个线程。
（2）线程是 CPU 调度的最小单位；进程是操作系统分配资源的最小单位。线程的划分尺度
小于进程，使得多线程程序的并发性高。
（3）线程是出于高并发的调度诉求，从进程内部演进而来。线程的出现，既充分发挥 CPU
的计算性能，弥补进程调度的过于笨重。
（4）进程之间是相互独立的；但进程内部各个线程之间，并不完全独立。各个线程之间共享
进程的方法区内存、堆内存、系统资源(文件句柄、系统信号等等)。
（5）切换速度不同：线程上下文切换比进程上下文切换要快得多。所以，有的时候，线程也
称之为轻量级进程。

1.3 创建线程的四种方法
    Java 进程中每一个线程都对应着一个 Thread 实例。线程的描述信息在 Thread 的实例属性中
得到保存，供 JVM 进行线程管理和调度时使用。
    虽然一条进程有很多个线程，但是在一个 CPU 内核上，同一时刻只能有一个
线程是正在执行的线程，该线程也被叫做当前线程。
    Thread 类除了定义了很多操作线程实例的成员方法之外，还有一系列的类的静态方法。比方
说上一节用到的 Thread.currentThread()静态方法就是其中之一，该方法的作用是——取得当前
CPU 内核上正在运行的线程实例。
    Thread 类是 Java 多线程编程的基础。Java 中虽然有三种方式创建一个线程，但是，三种方式
都会涉及到 Thread 类
1.3.1 Thread 类详解
一个线程在 Java 中使用一个 Thread 实例来描述。Thread 类是 Java 语言一个重要的基础类，
位于 java.lang 包中。Thread 类有不少非常重要的属性和方法，用于存储和操作线程的描述信息，
该类的结构图，大致如图 1-5 所示。
1. 线程 Id 2. 线程名称 3. 线程优先级 4. 是否为守护线程 5. 线程的状态
    在 Java 线程的状态中，就绪状态和运行状态在内部都用同一种状态 RUNNABLE 表示。就绪
状态表示线程具备运行条件，正在等待获取 CPU 时间片；运行状态表示线程已经获取了 CPU 时
间片，CPU 正在执行线程代码逻辑。
6. 线程的启动和运行
用来启动一个线程，当调用 start 方法后，JVM 才会开启一个新
的线程来执行用户定义的线程代码逻辑，在这个过程中，会为新应的线程分配需要的资源。
作为线程代码逻辑的入口方法。run 方法不是由用户程序来调用

  当调用 start 方法启动一个线程之后，只要线程获得了 CPU 执行时间，便进入 run 方法体去
执行具体的用户线程代码。
1.3.2 创建一个空线程
        */
